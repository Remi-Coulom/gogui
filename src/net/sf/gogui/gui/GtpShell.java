//----------------------------------------------------------------------------
// $Id$
//----------------------------------------------------------------------------

package net.sf.gogui.gui;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.Frame;
import java.awt.Point;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.prefs.Preferences;
import javax.swing.Box;
import javax.swing.ComboBoxEditor;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextField;
import javax.swing.JViewport;
import javax.swing.SwingUtilities;
import net.sf.gogui.gtp.GtpClient;
import net.sf.gogui.gtp.GtpUtil;
import net.sf.gogui.util.Platform;
import net.sf.gogui.util.PrefUtil;

/** Dialog for displaying the GTP stream and for entering commands. */
public class GtpShell
    extends JDialog
    implements ActionListener, GtpClient.IOCallback
{
    /** Callback for events generated by GtpShell. */
    public interface Listener
    {
        void actionSendCommand(String command, boolean isCritical,
                               boolean showError);
    }

    public GtpShell(Frame owner, Listener listener,
                    MessageDialogs messageDialogs)
    {
        super(owner, "Shell");
        m_messageDialogs = messageDialogs;
        m_listener = listener;
        Preferences prefs = Preferences.userNodeForPackage(getClass());
        m_historyMin = prefs.getInt("history-min", 2000);
        m_historyMax = prefs.getInt("history-max", 3000);
        JPanel panel = new JPanel(new BorderLayout());
        getContentPane().add(panel, BorderLayout.CENTER);
        m_gtpShellText = new GtpShellText(m_historyMin, m_historyMax, false);
        m_scrollPane =
            new JScrollPane(m_gtpShellText.get(),
                            JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,
                            JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
        if (Platform.isMac())
            // Default Apple L&F uses no border, but Quaqua 3.7.4 does
            m_scrollPane.setBorder(null);
        int fontSize = m_gtpShellText.get().getFont().getSize();
        m_finalSize = new Dimension(fontSize * 40, fontSize * 30);
        panel.add(m_scrollPane, BorderLayout.CENTER);
        panel.add(createCommandInput(), BorderLayout.SOUTH);
        GuiUtil.setMinimumSize(this, new Dimension(160, 112));
        pack();
    }
    
    public void actionPerformed(ActionEvent event)
    {
        String command = event.getActionCommand();
        if (command.equals("comboBoxEdited"))
        {
        }
        else if (command.equals("run"))
            commandEntered();
        else if (command.equals("close"))
            setVisible(false);
    }

    /** @see net.sf.gogui.gui.GtpShellText#isLastTextNonGTP */
    public boolean isLastTextNonGTP()
    {
        return m_gtpShellText.isLastTextNonGTP();
    }

    public void receivedInvalidResponse(String response)
    {
        if (SwingUtilities.isEventDispatchThread())
        {
            appendInvalidResponse(response);
            return;
        }
        Runnable r = new UpdateInvalidResponse(this, response);
        invokeAndWait(r);
    }
    
    public void receivedResponse(boolean error, String response)
    {
        if (SwingUtilities.isEventDispatchThread())
        {
            appendResponse(error, response);
            return;
        }
        Runnable r = new UpdateResponse(this, error, response);
        invokeAndWait(r);
    }
    
    public void receivedStdErr(String s)
    {
        if (SwingUtilities.isEventDispatchThread())
        {
            appendLog(s);
            return;
        }
        Runnable r = new UpdateStdErr(this, s);
        invokeAndWait(r);
    }

    public void saveLog(JFrame parent)
    {
        save(parent, m_gtpShellText.getLog(),
             m_gtpShellText.getLinesTruncated());
    }

    public void saveCommands(JFrame parent)
    {
        save(parent, m_commands.toString(), m_linesTruncated);
    }

    public void saveHistory()
    {
        int maxHistory = 100;
        int max = m_history.size();
        if (max > maxHistory)
            max = maxHistory;
        ArrayList list = new ArrayList(max);
        for (int i = m_history.size() - max; i < m_history.size(); ++i)
            list.add(m_history.get(i));
        PrefUtil.putList("net/sf/gogui/gui/gtpshell/recentcommands", list);
    }

    public void setCommandInProgess(boolean commandInProgess)
    {
        m_commandInProgress = commandInProgess;
    }

    public void setCommandCompletion(boolean commandCompletion)
    {
        m_disableCompletions = ! commandCompletion;
    }

    public void setTimeStamp(boolean enable)
    {
        m_gtpShellText.setTimeStamp(enable);
    }

    public void sentCommand(String command)
    {
        if (SwingUtilities.isEventDispatchThread())
        {
            appendSentCommand(command);
            return;
        }
        Runnable r = new UpdateCommand(this, command);
        invokeAndWait(r);
    }
    
    /** Modify dialog size after first write.
        This is a workaround for problems with a JTextPane in a JScrollable
        in Sun JDK 1.4 and Mac JDK 1.4.
        Sometimes garbage text is left after inserting text
        if the JTextPane was created empty and the size was set by
        JScrollpane.setPreferredSize or letting the scrollable track the
        viewport width.
        The garbage text disappears after resizing the dialog,
        so we use JDialog.setSize after the first text was inserted.
        To use this workaround, you should call setFinalSize(int,int) instead
        of setSize(int,int). The final size will be remembered, but only
        applied after the next text is inserted.
        This workaround should be removed when no longer needed (e.g. after
        requiring newer Java versions that don't need this workaround).
    */
    public void setFinalSize(int width, int height)
    {
        if (m_isFinalSizeSet)
            setSize(width, height);
        else
            m_finalSize = new Dimension(width, height);
    }

    public void setInitialCompletions(ArrayList completions)
    {
        for (int i = completions.size() - 1; i >= 0; --i)
        {
            String command = completions.get(i).toString();
            if (! GtpUtil.isStateChangingCommand(command))
                appendToHistory(command);
        }
        ArrayList list =
            PrefUtil.getList("net/sf/gogui/gui/gtpshell/recentcommands");
        for (int i = 0; i < list.size(); ++i)
            appendToHistory((String)list.get(i));
        addAllCompletions(m_history);
    }

    public void setProgramCommand(String command)
    {
        m_programCommand = command;
    }

    public void setProgramName(String name)
    {
        m_programName = name;
    }

    public void setProgramVersion(String version)
    {
        m_programVersion = version;
    }

        
    private static class UpdateCommand implements Runnable
    {
        public UpdateCommand(GtpShell gtpShell, String text)
        {
            m_gtpShell = gtpShell;
            m_text = text;
        }

        public void run()
        {
            m_gtpShell.appendSentCommand(m_text);
        }

        private final String m_text;

        private final GtpShell m_gtpShell;
    }

    private static class UpdateInvalidResponse implements Runnable
    {
        public UpdateInvalidResponse(GtpShell gtpShell, String text)
        {
            m_gtpShell = gtpShell;
            m_text = text;
        }

        public void run()
        {
            m_gtpShell.appendInvalidResponse(m_text);
        }

        private final String m_text;

        private final GtpShell m_gtpShell;
    }

    private static class UpdateResponse implements Runnable
    {
        public UpdateResponse(GtpShell gtpShell, boolean error, String text)
        {
            m_gtpShell = gtpShell;
            m_error = error;
            m_text = text;
        }

        public void run()
        {
            m_gtpShell.appendResponse(m_error, m_text);
        }

        private final boolean m_error;

        private final String m_text;

        private final GtpShell m_gtpShell;
    }

    private static class UpdateStdErr implements Runnable
    {
        public UpdateStdErr(GtpShell gtpShell, String text)
        {
            m_gtpShell = gtpShell;
            m_text = text;
        }

        public void run()
        {
            assert(SwingUtilities.isEventDispatchThread());
            m_gtpShell.appendLog(m_text);
        }

        private final String m_text;

        private final GtpShell m_gtpShell;
    }

    /** Wrapper object for JComboBox items.
        JComboBox can have focus and keyboard navigation problems if
        duplicate String objects are added.
        See JDK 1.4 doc for JComboBox.addItem.
    */
    private static class WrapperObject
    {
        WrapperObject(String item)
        {
            m_item = item;
        }

        public String toString()
        {
            return m_item;
        }

        private final String m_item;
    }

    private boolean m_disableCompletions;

    private boolean m_isFinalSizeSet;

    private boolean m_commandInProgress;

    private final int m_historyMax;

    private final int m_historyMin;

    private int m_linesTruncated;

    private int m_numberCommands;

    /** Serial version to suppress compiler warning.
        Contains a marker comment for serialver.sourceforge.net
    */
    private static final long serialVersionUID = 0L; // SUID

    private final Listener m_listener;

    private ComboBoxEditor m_editor;

    private Dimension m_finalSize;

    private JButton m_runButton;

    private JTextField m_textField;

    private JComboBox m_comboBox;

    private final JScrollPane m_scrollPane;

    private final GtpShellText m_gtpShellText;

    private final StringBuffer m_commands = new StringBuffer(4096);

    private final ArrayList m_history = new ArrayList(128);

    private String m_programCommand = "unknown";

    private String m_programName = "unknown";

    private String m_programVersion = "unknown";

    private MessageDialogs m_messageDialogs;

    private void addAllCompletions(ArrayList completions)
    {
        // On Windows JDK 1.4 changing the popup automatically
        // selects all text in the text field, so we remember and
        // restore the state.
        String oldText = m_textField.getText();
        int oldCaretPosition = m_textField.getCaretPosition();
        if (completions.size() > m_comboBox.getItemCount())
            m_comboBox.hidePopup();
        m_comboBox.removeAllItems();
        for (int i = completions.size() - 1; i >= 0; --i)
        {
            Object object = new WrapperObject((String)completions.get(i));
            m_comboBox.addItem(object);
        }
        m_comboBox.setSelectedIndex(-1);
        m_textField.setText(oldText);
        m_textField.setCaretPosition(oldCaretPosition);
    }

    private void appendInvalidResponse(String response)
    {
        assert(SwingUtilities.isEventDispatchThread());
        m_gtpShellText.appendInvalidResponse(response);
    }
    
    private void appendLog(String line)
    {
        assert(SwingUtilities.isEventDispatchThread());
        m_gtpShellText.appendLog(line);
        setFinalSize();
    }
    
    private void appendResponse(boolean error, String response)
    {
        assert(SwingUtilities.isEventDispatchThread());
        if (error)
            m_gtpShellText.appendError(response);
        else
            m_gtpShellText.appendInput(response);
        setFinalSize();
    }
    
    private void appendSentCommand(String command)
    {
        assert(SwingUtilities.isEventDispatchThread());
        m_commands.append(command);
        m_commands.append('\n');
        ++m_numberCommands;
        if (m_numberCommands > m_historyMax)
        {
            int truncateLines = m_numberCommands - m_historyMin;
            String s = m_commands.toString();
            int index = GtpShellText.findTruncateIndex(s, truncateLines);
            assert(index != -1);
            m_commands.delete(0, index);
            m_linesTruncated += truncateLines;
            m_numberCommands = 0;
        }
        m_gtpShellText.appendOutput(command + "\n");
        setFinalSize();
    }
    
    private void appendToHistory(String command)
    {
        command = command.trim();
        int i = m_history.indexOf(command);
        if (i >= 0)
            m_history.remove(i);
        m_history.add(command);
    }

    private void commandEntered()
    {
        assert(SwingUtilities.isEventDispatchThread());
        String command = m_textField.getText().trim();
        if (command.trim().equals(""))
            return;
        if (command.startsWith("#"))
        {
            m_gtpShellText.appendComment(command + "\n");
        }
        else
        {
            if (GtpUtil.isStateChangingCommand(command))
            {
                showError("Cannot send board changing command from GTP shell",
                          "Use the graphical board to start new games, "
                          + "play moves, and for all other actions that "
                          + " change the state of the board.", false);
                return;
            }
            if (m_commandInProgress)
            {
                showError("Cannot execute while computer is thinking",
                          "You need to wait until the command in "
                          + " progress is finished.",
                          false);
                return;
            }
            m_listener.actionSendCommand(command, false, false);
        }
        appendToHistory(command);
        m_gtpShellText.setPositionToEnd();
        m_comboBox.hidePopup();
        addAllCompletions(m_history);
        m_editor.setItem(null);
    }

    private JComponent createCommandInput()
    {
        Box box = Box.createVerticalBox();
        //JPanel panel = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
        JPanel panel = new JPanel(new BorderLayout());
        box.add(GuiUtil.createSmallFiller());
        box.add(Box.createVerticalGlue());
        box.add(panel);
        box.add(Box.createVerticalGlue());
        m_comboBox = new JComboBox();
        if (Platform.isMac())
            // Workaround for bug in Quaqua Look and Feel 3.6.11
            m_comboBox.setMaximumRowCount(7);
        m_editor = m_comboBox.getEditor();
        m_textField = (JTextField)m_editor.getEditorComponent();
        m_textField.setFocusTraversalKeysEnabled(false);
        KeyAdapter keyAdapter = new KeyAdapter()
            {
                public void keyReleased(KeyEvent e) 
                {
                    int c = e.getKeyCode();        
                    int mod = e.getModifiers();
                    if (c == KeyEvent.VK_ESCAPE)
                        return;
                    else if (c == KeyEvent.VK_TAB)
                    {
                        findBestCompletion();
                        popupCompletions();
                    }
                    else if (c == KeyEvent.VK_PAGE_UP
                             && mod == ActionEvent.SHIFT_MASK)
                        scrollPage(true);
                    else if (c == KeyEvent.VK_PAGE_DOWN
                             && mod == ActionEvent.SHIFT_MASK)
                        scrollPage(false);
                    else if (c == KeyEvent.VK_ENTER
                             && ! m_comboBox.isPopupVisible())
                        commandEntered();
                    else if (e.getKeyChar() != KeyEvent.CHAR_UNDEFINED)
                        popupCompletions();
                }
            };
        m_textField.addKeyListener(keyAdapter);
        m_comboBox.setEditable(true);
        m_comboBox.setFont(m_gtpShellText.get().getFont());
        m_comboBox.addActionListener(this);
        addWindowListener(new WindowAdapter() {
                public void windowActivated(WindowEvent e) {
                    m_comboBox.requestFocusInWindow();
                    m_textField.requestFocusInWindow();
                }
            });
        panel.add(m_comboBox, BorderLayout.CENTER);
        m_runButton = new JButton();
        m_runButton.setIcon(GuiUtil.getIcon("gogui-key_enter", "Run"));
        m_runButton.setActionCommand("run");
        m_runButton.setFocusable(false);
        m_runButton.setToolTipText("Send command line");
        m_runButton.addActionListener(this);
        m_runButton.putClientProperty("Quaqua.Button.style", "bevel");
        JPanel buttonPanel =
            new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
        panel.add(buttonPanel, BorderLayout.EAST);
        buttonPanel.add(GuiUtil.createSmallFiller());
        buttonPanel.add(m_runButton);
        // Workaround for Java 1.4.1 on Mac OS X add some empty space
        // so that combobox does not overlap the window resize widget
        if (Platform.isMac())
        {
            Dimension dimension = new Dimension(20, 1);
            Box.Filler filler =
                new Box.Filler(dimension, dimension, dimension);
            buttonPanel.add(filler);
        }
        return box;
    }

    private void findBestCompletion()
    {
        String text = m_textField.getText().trim();
        if (text.equals(""))
            return;
        String bestCompletion = null;
        for (int i = 0; i < m_history.size(); ++i)
        {
            String completion = (String)m_history.get(i);
            if (completion.startsWith(text))
            {
                if (bestCompletion == null)
                {
                    bestCompletion = completion;
                    continue;
                }
                int j = text.length();
                while (true)
                {
                    if (j >= bestCompletion.length())
                    {
                        break;
                    }
                    if (j >= completion.length())
                        break;
                    if (bestCompletion.charAt(j) != completion.charAt(j))
                        break;
                    ++j;
                }
                bestCompletion = completion.substring(0, j);
            }
        }       
        if (bestCompletion != null)
            m_textField.setText(bestCompletion);
    }

    private void invokeAndWait(Runnable runnable)
    {
        try
        {
            SwingUtilities.invokeAndWait(runnable);
        }
        catch (InterruptedException e)
        {
            System.err.println("Thread interrupted");
        }
        catch (java.lang.reflect.InvocationTargetException e)
        {
            System.err.println("InvocationTargetException");
        }
    }

    private void popupCompletions()
    {
        String text = m_textField.getText();
        text = text.replaceAll("^ *", "");
        ArrayList completions = new ArrayList(128);
        for (int i = 0; i < m_history.size(); ++i)
        {
            String c = (String)m_history.get(i);
            if (c.startsWith(text))
                completions.add(c);
        }
        addAllCompletions(completions);
        if (m_disableCompletions)
            return;
        int size = completions.size();
        if (text.length() > 0
            && (size > 1 || (size == 1 && ! text.equals(completions.get(0)))))
            m_comboBox.showPopup();
        else
            m_comboBox.hidePopup();
    }

    private void save(JFrame parent, String s, int linesTruncated)
    {
        File file = FileDialogs.showSave(parent, null, m_messageDialogs);
        if (file == null)
            return;
        try
        {
            PrintStream out = new PrintStream(new FileOutputStream(file));
            out.println("# Name: " + m_programName);
            out.println("# Version: " + m_programVersion);
            out.println("# Command: " + m_programCommand);
            out.println("# Lines truncated: " + linesTruncated);
            out.print(s);
            out.close();
        }
        catch (FileNotFoundException e)
        {
            m_messageDialogs.showError(parent, "Could not save to file.", "");
        }
    }

    private void setFinalSize()
    {
        if (m_isFinalSizeSet)
            return;
        setSize(m_finalSize);
        m_isFinalSizeSet = true;
    }

    private void showError(String mainMessage, String optionalMessage,
                           boolean isCritical)
    {
        m_messageDialogs.showError(this, mainMessage, optionalMessage,
                                   isCritical);
    }

    private void scrollPage(boolean up)
    {
        JViewport viewport = m_scrollPane.getViewport();
        Point position = viewport.getViewPosition();
        int delta = m_scrollPane.getSize().height
            - m_gtpShellText.get().getFont().getSize();
        if (up)
        {
            position.y -= delta;
            if (position.y < 0)
                position.y = 0;
        }
        else
        {
            position.y += delta;
            int max = viewport.getViewSize().height
                - m_scrollPane.getSize().height;
            if (position.y > max)
                position.y = max;
        }
        viewport.setViewPosition(position);
    }
}
